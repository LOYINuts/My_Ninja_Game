# 学习笔记

1. pygame的左边从左上开始(0,0),向下和向右为正

2. FPS帧数不是越快越好，因为要做很多事情，越快占用CPU越高

3. 我们的小游戏什么都在一个循环，大游戏可能不止一个循环

4. blit方法其实就是把某部分内存粘贴到另一个surface(在pygame surface其实就是图片(image),screen也是一种surface，特殊的surface。大多数surface其实就是内存中的图片的表示)

5. blit其实是在原来的surface上再粘贴，所以如果直接简单的移动就会像拖这一样有残影，我们需要清除原先的图片

6. color_set使某个颜色变为透明

7. 矩形有更简单的方法pygame.Rect(\*img_pos,\*img.size())

8. pygame里谁先画出来在图层的最下层，即会被之后画上去的覆盖

9. 两种方式画地图，一种使用列表\[\[1,1,1,1\][0,0,0,]\]这种，比较繁琐，中间的也要你敲数值

   另一种就是教程更推荐的,那块是什么：

   {(0,0): 'grass', (0,1): 'dirt',(9999,1): 'grass'}，这种直接写某个坐标是什么，中间的就不管

10. Windows系统自动排序文件为字典序，但是LINUX可能不同，所以使用sorted来排个序

11. 但是10会排在9前面，这样顺序又乱了，所以我们得在前面加0，例如00,01，02.。。这样10就会排在后面

12. 为什么要自己在弄一个位置，而不直接用矩形Rect的位置，是因为矩形的位置不支持浮点数，移动就有问题

13. 以玩家为中心，那么计算相机偏移值就是人物的中心x减去界面的一半宽度，如果x大于一半说明在中心右边。相机就得往右移动。然后还要减去之前的屏幕移动距离，看与之前相比，是否离中心更近了，如果更近了那么屏幕移动速度就要变小(因为用的是+=如果不这样屏幕会一直移动)

    最后除以30是为了屏幕不要真的一直跟随移动，慢慢移动

    速度越快屏幕移动越快

14. 这样处理会导致人物抖动，因为人物的xy坐标是浮点数不是整数，滚动的距离也不是浮点数(即使转换为int会有一些问题，但是这些问题都不是很大，特别使用在相机上)

15. 屏幕放大技巧，先把东西画在小的surface上面，然后使用scale放大到窗口一样的size

16. 云的render函数里面，我们想要云一直飘，就是左边出去右边又进来，那么我们在画的时候要设置好位置，位置要取窗口大小和自身大小的模，免得没到左边又传送到右边(云没出去完)，再减去自身云的大小，因为坐标只管左上角，减去这个进行调整？

17. 根据depth渲染，先渲染在里面的，然后渲染外面的，这样深的云就会被浅云遮挡，然后这个偏移offset乘上深度就能搞出立体的效果我没懂这个原理但是好无敌。

18. 我们不想在屏幕上画出所有的物体，我们只想画出可能被展示(被摄像头捕捉到的物体)

19. python 的 等于赋值其实如果是一个list赋给另一个，他并不是复制，而只是给了个引用，还是一个列表

20. 因为动画有些图片比原本的站立图片要大，所以使用offset让它偏移处理，本来应该每个动画特殊处理，但是这里为了简单使用(-3,-3)

21. 鼠标按键1,2,3,4,5分别是左，中，右，上滚轮，下滚轮

22. 显示鼠标准备放置的装饰，需要对坐标再一次修改，使用已经计算的tile_pos乘上tile_size(之前在tilemap讲过，如果不是offgrid_tile就要乘上tile_size)然后减去偏移值

23. 因为offgrid_tile我们不知道具体的坐标，不好删除，所以用个笨方法

24. 假设要编辑的地图就在当前目录下，就叫map.json，我们每次打开编辑器就会加载这个

25. 虽然有个关卡编辑器，但仍然十分的繁琐如果手绘制地图，我们写一个自动补全的函数，不能把列表作为键，而如果传入元组的话万一邻居一样但是顺序不一样，也不行，所以我们就先排序然后再转成元组，这样不管传入的是什么都一样

26. 键的值见图片命名，0号图片可以看出就是放左上角的，而左上角有下，右两个邻居

27. 冲刺仍要设置个减速，dashing设置数字这么大同时可以运作于冷却。一举多得

28. 搞半天angle和speed是为了更合理，粒子散射的更合理，angle使用2pi乘上0到1，就是整个角度，然后speed取[0.5,1]，大概就是这样，然后cos算x，sin算y

29. 如果在迭代过程中对字典进行了修改，例如添加或删除键值对，那么字典的大小就会发生变化，从而导致迭代过程出现错误。这是因为 Python 在迭代过程中会检查字典的大小是否保持不变，以确保迭代过程的一致性和准确性。我们在字典后面加个copy复制一份就好，

30. 敌人随机行走往前后看7个像素，如果前方地上还有路则继续走否则掉头，传入的参数+-7就是前看7个像素，y的值为敌人的人物大小(8,15)的15+半个tile的大小8就是23

31. 子弹应该可以单独做一个class但是太简单了所以就直接写了

32. 粒子效果这块有点没太懂随便吧

26. displayer放有阴影的，displayer_2没有阴影，简单来说这个阴影的实现方法就是把原来的画面转成黑白再画一次，把原来的画面覆盖再上面但是有偏移，那么黑白的部分就相当于阴影一样